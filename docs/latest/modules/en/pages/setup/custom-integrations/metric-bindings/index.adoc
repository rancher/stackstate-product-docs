ifdef::ss-ff-stackpacks2_enabled[]
= Add custom charts to components
:revdate: 2025-07-10
:page-revdate: {revdate}
:description: SUSE Observability

== Overview

{stackstate-product-name} provides already many metric charts by default on most types of components that represent Kubernetes resources. Extra metric charts can be added to any set of components whenever needed. When adding metrics to components there are two options:

. The metrics are already collected by {stackstate-product-name} but aren't visualized on a component, by default
. The metrics aren't yet collected by {stackstate-product-name} at all and therefore aren't available yet

For option 1, the steps below will instruct you on how to create a metric binding which will configure {stackstate-product-name} to add a specific metric to a specific set of components.

For option 2, ensure the metrics are available in {stackstate-product-name} by sending them to {stackstate-product-name} using the xref:/use/metrics/k8s-prometheus-remote-write.adoc[Prometheus remote write protocol]. Continue by adding charts for the metrics to the components ONLY after ensuring the metrics are available.

== Creating a metric binding

. <<_create_an_outline_of_the_metric_binding,Create an outline of the metric binding>>
. <<_select_the_components_to_bind_to,Select the components to bind to>>
. <<_write_the_promql_query,Write the PromQL query for the desired metric>>
. <<_bind_the_correct_time_series_to_each_component,Bind the correct time series to each component>>

For example, the steps will add a metric binding for the `Replica counts`  of Kubernetes deployments. This metric binding already exists in {stackstate-product-name}, by default.

=== Create an outline of the metric binding

Open the `metricbindings.yaml` YAML file in your favorite code editor to change it throughout this guide.  You can use the CLI to xref:/setup/custom-integrations/develop.adoc#_test_your_stackpack[Test Your StackPack].

----
- _type: MetricBinding
  chartType: line
  enabled: true
  identifier: urn:stackpack:my-stackpack:shared:metric-binding:node-memory-bytes-available-scheduling
  layout:
    metricPerspective:
      section: Resources
      tab: Kubernetes Node
  name: Memory available for scheduling (Custom)
  priority: medium
  queries:
  - alias: ${cluster_name} - ${node}
    expression: max_over_time(kubernetes_state_node_memory_allocatable{cluster_name="${tags.cluster-name}", node="${name}"}[${__interval}])
  scope: (label = "stackpack:kubernetes" and type = "node")
  unit: bytes(IEC)
----

The queries and scope section will be filled in the next steps. Note that the unit used is `short`, which will simply render a numeric value. In case you're not sure yet about the unit of the metric, you can leave it open and decide on the correct unit when writing the PromQL query.

=== Select the components to bind to

Save a view of the xref:/use/views/k8s-topology-perspective.adoc[Topology perspective] and use the filters (Filters -> Topology -> Switch to STQL) to query the components that need to show the new metric. The most common fields to select topology on for metric bindings are `type` for the component type and `label` for selecting all the labels. For example for the deployments:

----
type = "deployment" and label = "stackpack:kubernetes"
----

The type filter selects all deployments, while the label filter selects only components created by the Kubernetes stackpack (label name is `stackpack` and label value is `kubernetes`). The latter can also be omitted to get the same result.  All xref:/develop/reference/k8sTs-stql_reference.adoc#_component_filters[STQL query Component Filters] can be used for filtering.

Switch to the advanced mode to copy the resulting topology query and put it in the `scope` field of the metric binding.

[NOTE]
====
Metric bindings only support the query filters. Query functions like `withNeighborsOf` are not supported and cannot be used.
====


=== Write the PromQL query

Go to the xref:/use/metrics/k8sTs-explore-metrics.adoc[metric explorer] of your {stackstate-product-name} instance, http://your-instance/#/metrics, and use it to query for the metric of interest. The explorer has auto-completion for metrics, labels, label values but also PromQL functions, and operators to help you out. Start with a short time range of, for example, an hour to get the best results.

For the total number of replicas, use the `kubernetes_state_deployment_replicas` metric. To show the metrics charts of the time series data, extend the query to do an aggregation using the `+${__interval}+` parameter:

----
max_over_time(kubernetes_state_deployment_replicas[${__interval}])
----

In this specific case, use `max_over_time` to make sure the chart always shows the highest number of replicas at any given time. For longer time ranges, a short dip in replicas are not shown. To emphasize the lowest number of replicas, use `min_over_time` instead.

Copy the query into the `expression` property of the first entry in the `queries` field of the metric binding. Use `Total replicas` as an alias. for it to show up in the chart legend.

[NOTE]
====
In {stackstate-product-name}, the size of the metric chart automatically determines the granularity of the metric shown in the chart. PromQL queries can adjusted to make optimal use of this behavior to get a representative chart for the metric. xref:/setup/custom-integrations/metric-bindings/writing-promql.adoc[Writing PromQL for charts] explains this in detail.
====


=== Bind the correct time series to each component

The metric binding with all fields filled in:

----
_type: MetricBinding
chartType: line
enabled: true
tags: {}
unit: short
name: Replica counts
priority: MEDIUM
identifier: urn:stackpack:my-stackpack:metric-binding:my-deployment-replica-counts
queries:
  - expression: max_over_time(kubernetes_state_deployment_replicas[${__interval}])
    alias: Total replicas
scope: type = "deployment" and label = "stackpack:kubernetes"
----

Creating it in {stackstate-product-name} and viewing the "Replica count" chart on a deployment component gives an unexpected result. The chart shows the replica counts for all deployments. Logically one would expect only one time series: the replica count for this specific deployment.

image::k8s/k8s-replica-counts-without-binding.png[The incorrect chart for a single deployment, it shows the replica count for all deployments]

To fix this make the PromQL query specific for a component using information from the component. Filter on enough metric labels to select only the specific time series for the component. This is the "binding" of the correct time series to the component. For anyone experienced in making Grafana dashboards this is similar to a dashboard with parameters that are used in queries on the dashboard. Let's change the query in the metric binding to this:

----
max_over_time(kubernetes_state_deployment_replicas{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", deployment="${name}"}[${__interval}])
----

image::k8s/k8s-replica-counts-with-binding.png[After adding the parameterized filters the resulting chart looks as expected, only one time series for this component]

The PromQL query now filters on three labels, `cluster_name`, `namespace` and `deployment`. Instead of specifying an actual value for these labels a variable reference to fields of the component is used. In this case the labels `cluster-name` and `namespace` are used, referenced using `${tags.cluster-name}` and `${tags.namespace}`. Further the component name is referenced with `+${name}+`.

Supported variable references are:

* Any component label, using `${tags.<label-name>}`
* The component name, using `+${name}+`

image::k8s/k8s-carts-highlights.png[Component Highlights page that shows the labels and component name (both highlighted in red)]

[NOTE]
====
The cluster name, namespace and a combination of the component type and name are ususally enough for selecting the metrics for a specific component from Kubernetes. These labels, or similar labels, are usually available on most metrics and components.
====


== Advanced

=== More than one time series in a chart

[NOTE]
====
There is only one unit for a metric binding (it gets plotted on the y-axis of the chart). As a result you should only combine queries that produce time series with the same unit in one metric binding. Sometimes it might be possible to convert the unit. For example, CPU usage might be reported in milli-cores or cores, milli-cores can be converted to cores by multiplying by 1000 like this  `(<original-query>) * 1000`.
====


There are two ways to get more than one time series in a single metric binding and therefore in a single chart:

. Write a PromQL query that returns multiple time series for a single component
. Add more PromQL queries to the metric binding

For the first option an example is given in the xref:/setup/custom-integrations/metric-bindings/index.adoc#_using_metric_labels_in_aliases[next section]. The second option can be useful for comparing related metrics. Some typical use-cases:

* Comparing total replicas vs desired and available
* Resource usage: limits, requests and usage in a single chart

To add more queries to a metric binding simply repeat xref:/setup/custom-integrations/metric-bindings/index.adoc#_steps[steps] 3. and 4. and add the query as an extra entry in the list of queries. For the deployment replica counts there are several related metrics that can be included in the same chart:

----
- _type: MetricBinding
  chartType: line
  enabled: true
  tags: {}
  unit: short
  name: Replica counts
  priority: MEDIUM
  identifier: urn:stackpack:my-stackpack:metric-binding:my-deployment-replica-counts
  queries:
    - expression: max_over_time(kubernetes_state_deployment_replicas{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", deployment="${name}"}[${__interval}])
      alias: Total replicas
    - expression: max_over_time(kubernetes_state_deployment_replicas_available{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Available - ${cluster_name} - ${namespace} - ${deployment}
    - expression: max_over_time(kubernetes_state_deployment_replicas_unavailable{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Unavailable - ${cluster_name} - ${namespace} - ${deployment}
    - expression: min_over_time(kubernetes_state_deployment_replicas_desired{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Desired - ${cluster_name} - ${namespace} - ${deployment}
  scope: type = "deployment" and label = "stackpack:kubernetes"
----

image::k8s/k8s-replica-counts-multiple-timeseries.png[Metric binding with multiple metrics]

=== Using metric labels in aliases

When a single query returns multiple time series per component, this will show as multiple lines in the chart. But in the legend they will all use the same alias. To be able to see the difference between the different time series the alias can include references to the metric labels using the `+${label}+` syntax. For example here is a metric binding for the "Container restarts" metric on a pod, note that a pod can have multiple containers:

----
type: MetricBinding
chartType: line
enabled: true
id: -1
identifier: urn:stackpack:my-stackpack:metric-binding:my-pod-restart-count
name: Container restarts
priority: MEDIUM
queries:
- alias: Restarts - ${container}
  expression: max by (cluster_name, namespace, pod_name, container) (kubernetes_state_container_restarts{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", pod_name="${name}"})
scope: (label = "stackpack:kubernetes" and type = "pod")
unit: short
----

Note that the `alias` references the `container` label of the metric. Make sure the label is present on the query result, when the label is missing the `+${container}+` will be rendered as literal text to help troubleshooting.

=== Layouts

Each component can be associated with various technologies or protocols such as k8s, networking, runtime environments (e.g., JVM), protocols (HTTP, AMQP), etc.
Consequently, a multitude of different metrics can be displayed for each component. For easier readability, {stackstate-product-name} can organize these charts into tabs and sections.
To display a chart (`MetricBinding`) within a specific tab or section, you need to configure the layout property.
Any MetricsBinding without a specified layout will be displayed in a tab and section named `Other`.

Here is an example configuration:

endif::ss-ff-stackpacks2_enabled[]
