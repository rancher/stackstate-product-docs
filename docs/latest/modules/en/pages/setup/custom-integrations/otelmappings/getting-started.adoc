ifdef::ss-ff-stackpacks2_enabled[]
= Getting Started
:revdate: 2025-12-23
:page-revdate: {revdate}
:description: Getting Started with deriving Topology from OpenTelemetry

== Overview

This document provides a getting started guide for building topology from OpenTelemetry (OTel) trace data using component and relation mappings packaged as part of a StackPack.

This guide focuses on topology that can be visualized immediately in the product using telemetry data that is already present.
The example topology that will be generated models how a service instance executes a process, derived from OpenTelemetry resource attributes.

== Prerequisites

* You already collect OpenTelemetry traces.
* You are creating or extending a StackPack.
* You are comfortable with YAML and basic OTel concepts (resources, spans).

The guide will focus on:

* Trace-based topology (`TRACES` signal only)
* Service instances (not logical services)
* Runtime process visibility

[NOTE]
====
In this guide, component and relation mappings are expressed as YAML configuration that is packaged, tested, and deployed as part of a StackPack.
====

== Configuring topology

The goal is to visualize runtime execution topology that is immediately available without additional user configuration.

Specifically, we want to model:

[source]
----
service instance (component) -> executes (relation) -> process (component)
----

Where:

* A `service instance` represents a running instance of an instrumented service.
* A `process` represents the operating system process executing that service.
* The `executes` relation indicates that the service instance is backed by, and running within, a specific process.

All of this topology is derived automatically from OpenTelemetry trace data.

== Trace data

In addition to service identity, the trace resource includes process-level attributes, such as:

* `process.pid`
* `process.executable.name`
* `process.executable.path`
* `process.command_args`
* `process.runtime.name`
* `process.runtime.version`

These attributes allow us to model process-level topology without span correlation or heuristics.

== Traces to topology: the mental model

Before writing any configuration, it’s important to understand how topology mappings work conceptually.

=== Components

A component mapping describes how a topology node is created from telemetry data.

Each component mapping:

* Selects telemetry using conditions.
* Extracts values using expressions.
* Produces a single logical component identified by a stable identifier.

In this guide:

* Service instances are provided by the OpenTelemetry StackPack.
* Processes are derived from OpenTelemetry resource attributes.

=== Relations

A relation mapping describes how a connection between two components is created.

Each relation mapping:

* Resolves a `sourceId` and a `targetId`.
* Assigns a relation type.
* Produces a directed edge.

Relations are created once both the source and target components exist.

== Creating service components from traces

=== Defining what a "service" means

Before writing the mapping, we need to make a design decision.

For this guide, a service is defined as:

* Identified by `service.namespace` + `service.name`.
* Stable across deployments.
* Independent of service instances.

This keeps topology readable and low cardinality.

== Service instance components

Service instance components are already defined and provided by the OpenTelemetry StackPack.

Each service instance:

* Is derived from `service.name`, `service.namespace`, and `service.instance.id`.
* Represents a concrete running instance of a service.
* Is stable across signals (traces and metrics).

Because this mapping already exists, it is not redefined in this guide.
Instead, we build on top of it.

== Creating process components from traces

=== Defining what a "process" means

For this guide, a process is defined as:

* Identified by `host.name`, `process.pid` and executable metadata.
* Scoped to a single runtime environment.
* Derived exclusively from OpenTelemetry resource attributes.

This keeps the topology low-cardinality while still exposing useful runtime detail.

=== Process component mapping

The following component mapping creates one topology component per observed process.

[,yaml]
----
_type: "OtelComponentMapping"
name: "OTel Process"
description: "Represents an operating system process derived from OpenTelemetry"
identifier: "urn:stackpack:<stackpack-name>:shared:otel-component-mapping:process"
input:
  signal:
    - "TRACES"
  resource:
    condition: |
      'host.name' in resource.attributes &&
      'process.pid' in resource.attributes
    action: "CREATE"
vars:
  - name: "pid"
    value: "${string(int(resource.attributes['process.pid']))}"
  - name: "hostname"
    value: "${resource.attributes['host.name']}"
  - name: "executableName"
    value: >-
      ${
        'process.executable.name' in resource.attributes ?
         resource.attributes['process.executable.name'] :
          'process.command' in resource.attributes ?
           resource.attributes['process.command'] :
            'process.command_args' in resource.attributes ?
             resource.attributes['process.command_args'] :
                resource.attributes['process.executable.path']
      }
output:
  identifier: "urn:opentelemetry:process/${vars.hostname}:${vars.pid}"
  name: "${vars.hostname}/${vars.executableName}:${vars.pid}"
  typeName: "process"
  typeIdentifier: "urn:stackpack:open-telemetry:shared:component-type:process"
  layerName: "Applications"
  domainName: "Open Telemetry"
  required:
    tags:
      - source: "process-component"
        target: "custom"
      - source: "${resource.attributes}"
        pattern: "process.(.*)"
        target: "process.${1}"
expireAfter: 900000
----

==== How this mapping works

* We process trace data only (TRACES signal).
* A process component is created whenever `host.name` and `process.pid` is present.
* The identifier is stable for the lifetime of the process.
* A custom tag is added to aid filtering (for the verification stage).

Substitute `<stackpack-name>` with the name of your StackPack (if you don't have one yet, use any name you like, like `mystackpack`).

== Creating executes relations

Now that service instances and processes exist as components, we can connect them.

=== Service instance executes process

The following relation mapping creates an `executes` relation from a service instance to a process.

This mapping is adapted from the existing "host executes service instance" relation provided by the OpenTelemetry StackPack.

[,yaml]
----
_type: "OtelRelationMapping"
name: "Executes Relation (Service Instance -> Process)"
description: "Service instance executes a process"
identifier: "urn:stackpack:<stackpack-name>:shared:otel-relation-mapping:executes-service-instance"
input:
  signal:
    - "TRACES"
  resource:
    condition: |
      'service.name' in resource.attributes &&
      'host.name' in resource.attributes &&
      'process.pid' in resource.attributes
    action: "CREATE"
vars:
  - name: "namespace"
    value: "${'service.namespace' in resource.attributes && resource.attributes['service.namespace'] != '' ? resource.attributes['service.namespace'] : 'default'}"
  - name: "service"
    value: "${resource.attributes['service.name']}"
  - name: "instanceId"
    value: >-
      ${
        'service.instance.id' in resource.attributes && resource.attributes['service.instance.id'] != '' ?
        resource.attributes['service.instance.id'] :
        resource.attributes['service.name']
      }
  - name: "hostname"
    value: "${resource.attributes['host.name']}"
  - name: "pid"
    value: "${string(int(resource.attributes['process.pid']))}"
output:
  sourceId: "urn:opentelemetry:namespace/${vars.namespace}:service/${vars.service}:serviceInstance/${vars.instanceId}"
  targetId: "urn:opentelemetry:process/${vars.hostname}:${vars.pid}"
  typeName: "executes"
expireAfter: 900000
----

==== How this mapping works

* We process trace data only (`TRACES` signal).
* The relation is created whenever both service instance and process data are present.
* No span correlation is required.
* The `targetId` expression needs to be the same as the process component mapping's `output.identifier` expression.

The relation identifier is constructed (automatically) from the `sourceId` and `targetId`, and is of the form: `sourceId-relationId`

Substitute `<stackpack-name>` with the name of your StackPack (if you don't have one yet, use any name you like, like `mystackpack`).

== Validating the OTel mappings

There are two options to validate the correctness of the mappings before deploying them to production.

1. Using the `sts stackpack test-deploy` command to package, upload and install/upgrade a StackPack containing the mappings to a running {stackstate-product-name} instance.
2. Using the `sts otel-component-mapping apply` and `sts otel-relation-mapping apply` commands to create/update the mappings individually to a running {stackstate-product-name} instance.

=== Testing the mappings together in a StackPack

Assuming both mappings live inside your StackPack, they can be tested together. Refer to xref:/setup/cli/cli-sts.adoc[StackPack CLI] documentation for more information.

Using the `sts stackpack test-deploy --yes` command, you can:

* Package, upload, and install/upgrade the StackPack
* Validate the declarative component and relation mappings residing in the StackPack (e.g., expression correctness, correct reference of input signal data based on filtering provided)

[NOTE]
====
The `sts stackpack test` command doesn't feed example trace data through the mappings.
To verify that the mappings produce the correct topology, ensure Open Telemetry trace data is sent to SUSE Observability.
Refer to the xref:/setup/custom-integrations/develop.adoc[Develop a Custom Integration (StackPack)] for more details on how to use `sts stackpack test`.
====

=== Testing the mappings individually

Assuming the above component and relation mappings are defined in YAML files, they can be applied individually.

Substitute `<stackpack-name>` with the name of your StackPack (if you don't have one yet, use any name you like, like `mystackpack`).

[,sh]
----
$ sts otel-component-mapping apply -f process-component-mapping.yaml
✅ OTel component mapping upserted successfully! Identifier: urn:stackpack:mystackpack:shared:otel-component-mapping:process, Name: OTel Process

$ sts otel-relation-mapping apply -f process-relation-mapping.yaml
✅ OTel Relation Mapping upserted successfully! Identifier: urn:stackpack:mystackpack:shared:otel-relation-mapping:executes-service-instance, Name: Executes Relation (Service Instance -> Process)
----

== Resulting topology

When these mappings are applied, the resulting topology forms a service-process topology graph derived entirely from trace data.

For example, using the `checkoutservice` from the OTel demo app, visually, the topology should appear as:

----
checkoutservice (instance) ─> executes ─> checkoutservice (process)
----

This topology updates continuously as new traces arrive and automatically expires when traffic stops.

=== View the resulting topology in {stackstate-product-name}

Use the {stackstate-product-name} UI to get visual confirmation that the mappings materialize into the expected topology.

1. Open the {stackstate-product-name} UI at the configured `baseUrl` Helm value
2. In the left-hand sidebar, click on `Open Telemetry > Services Instances`
3. Find the `checkoutservice` in the list of service instances and click on the service instance name to open the Component Overview/Highlights page
4. In the sub navigation-bar at the top, select `Topology`
5. In the `Outgoing` layer, an `od-checkoutservice-<hostId>/checkoutservice:1 (process)` node should be visible
6. Select the process node, and click `Explore component`
7. A smaller topology visualizing `checkoutservice -> executes -> checkoutservice (process)` should be visible

See the xref:/setup/custom-integrations/otelmappings/troubleshooting.adoc[Troubleshooting] guide for tips to debug if the topology is not materializing as expected.

image:custom-integrations/otel-mappings/topology_from_otel_guide_topology_result.png[Topology result]

To see all the process components created as a result of the process component mapping being applied, use the `sts topology inspect` command with a type filter.

[,sh]
----
$ sts topology inspect --type process
NAME                                                             | TYPE    | IDENTIFIERS
od-productcatalogservice-cf9d7b456-rlmp5/productcatalogservice:1 | process | urn:opentelemetry:process/od-productcatalogservice-cf9d7b456-rlmp5:1
od-adservice-6c9dfcfdbf-5pdqr//opt/java/openjdk/bin/java:1       | process | urn:opentelemetry:process/od-adservice-6c9dfcfdbf-5pdqr:1
od-frontend-685db864d9-6sh4d/node:17                             | process | urn:opentelemetry:process/od-frontend-685db864d9-6sh4d:17
od-paymentservice-bf8f84b5d-n8k77/node:17                        | process | urn:opentelemetry:process/od-paymentservice-bf8f84b5d-n8k77:17
od-quoteservice-859b8c5c4c-nkmgq/public/index.php:7              | process | urn:opentelemetry:process/od-quoteservice-859b8c5c4c-nkmgq:7
od-checkoutservice-78885bf588-59p9d/checkoutservice:1            | process | urn:opentelemetry:process/od-checkoutservice-78885bf588-59p9d:1
od-accountingservice-7c546cb977-xjp2c/accountingservice:1        | process | urn:opentelemetry:process/od-accountingservice-7c546cb977-xjp2c:1
----

== Cleaning up

To remove the mappings created in this guide, use the following commands:

Substitute `<stackpack-name>` with the name of your StackPack.

[,sh]
----
$ sts otel-component-mapping delete --identifier urn:stackpack:<stackpack-name>:shared:otel-component-mapping:process
✅ OTel Component Mapping deleted: urn:stackpack:mystackpack:shared:otel-component-mapping:process

$ sts otel-relation-mapping delete --identifier urn:stackpack:<stackpack-name>:shared:otel-relation-mapping:executes-service-instance
✅ OTel Relation Mapping deleted: urn:stackpack:mystackpack:shared:otel-relation-mapping:executes-service-instance
----


== Summary

In this guide, you:

* Built on existing service instance components.
* Derived process components from OpenTelemetry resource attributes.

== Next steps

From here, you can:

* Attach processes to hosts or containers.
* Introduce database or messaging relations.
* Introduce runtime-specific layers (JVM, Go, Node.js).
* Explore metrics-based service graphs.
* Extend the StackPack with additional topology layers.
* Familiarize yourself with an in-depth component and relation mapping xref:/setup/custom-integrations/otelmappings/schemas-ref.adoc[reference].

endif::ss-ff-stackpacks2_enabled[]
